# -*- coding: utf-8 -*-
"""22L-6951.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_gIbx5XsPtMZtw-vgmYsrHykpjBljWT
"""

#QUESTION NO. 01
from collections import deque
import numpy as np
import matplotlib.pyplot as plt


def visualize_path(matrix, path):
    rows, cols = len(matrix), len(matrix[0])
    fig, ax = plt.subplots(figsize=(7,7))

    # Create a grid visualization
    grid = np.array(matrix)
    for i in range(rows):
        for j in range(cols):
            color = 'white' if grid[i, j] == 0 else 'yellow'
            ax.add_patch(plt.Rectangle((j, rows - i - 1), 1, 1, color=color, edgecolor='green'))

    if path:
        for idx, (x, y) in enumerate(path):
            ax.text(y + 0.5, rows - x - 0.5, str(idx), fontsize=14, ha='center', va='center', color='blue')

    # Mark Start and End
    ax.text(0.5, rows - 0.5, 'S', fontsize=14, ha='center', va='center', color='pink', fontweight='bold')
    ax.text(3.5, rows - 3.5, 'H', fontsize=14, ha='center', va='center', color='red', fontweight='bold')

    ax.set_xticks(range(cols + 1))
    ax.set_yticks(range(rows + 1))
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.grid(True)
    plt.show()

def find_shortest_path(matrix):
    """Finds the shortest path in a 2D grid using BFS."""
    rows, cols = len(matrix), len(matrix[0])
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    start = (0, 0)
    end = (3, 3)

    queue = deque([(start, [])])
    visited = set()
    visited.add(start)

    while queue:
        (x, y), path = queue.popleft()

        if (x, y) == end:
            return path + [(x, y)]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] == 0 and (nx, ny) not in visited:
                queue.append(((nx, ny), path + [(x, y)]))
                visited.add((nx, ny))

    return None


matrix = [
    [0, 0, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 0, 0],
    [0, 1, 0, 0]
]

shortest_path = find_shortest_path(matrix)
print("Shortest Path:", shortest_path)

visualize_path(matrix, shortest_path)

#QUESTION NO. 02
import time
from collections import deque

def state_to_tuple(state):
    return tuple(state)

def get_moves(state):

    moves = []
    zero_index = state.index('0')
    row, col = zero_index // 3, zero_index % 3

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for dr, dc in directions:
        new_row, new_col = row + dr, col + dc
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_index = new_row * 3 + new_col
            new_state = list(state)
            new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
            moves.append(tuple(new_state))

    return moves

def dfs(start_state, goal_state, max_depth=30):
    stack = [(start_state, [], 0)]
    visited = set()

    while stack:
        current_state, path, depth = stack.pop()

        if current_state == goal_state:
            return path + [current_state]

        if depth >= max_depth:
            continue

        if current_state in visited:
            continue
        visited.add(current_state)


        for move in reversed(get_moves(current_state)):
            if move not in visited:
                stack.append((move, path + [current_state], depth + 1))

    return None

def main():
    """Main function to take input and execute the DFS algorithm."""
    start_state = input("Initial State: ")
    goal_state = input("End State: ")

    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(goal_state)

    print("***************")
    print("     DFS" )
    print("***************")

    start_time = time.time()
    solution_path = dfs(start_tuple, goal_tuple, max_depth=30)
    end_time = time.time()

    if solution_path:
        print("Time :", end_time - start_time, "sec")
        print("Path Cost:", len(solution_path))
        print("Nodes Visited:", len(solution_path) + 1)
        for state in solution_path:
            for i in range(0, 9, 3):
                print(' '.join(state[i:i+3]))
            print("*****")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()

# QUESTION NO.03
import heapq

class Graph:
    def __init__(self, adjacency_list, heuristic):
        self.adjacency_list = adjacency_list
        self.heuristic = heuristic

    def get_neighbors(self, node):
        return self.adjacency_list.get(node, {})

    def a_star_algorithm(self, start_node, stop_node):
        open_list = []
        heapq.heappush(open_list, (0, start_node))
        g = {start_node: 0}
        parents = {start_node: None}

        while open_list:
            _, current_node = heapq.heappop(open_list)

            if current_node == stop_node:
                return self.reconstruct_path(parents, stop_node, g[stop_node])

            for neighbor, cost in self.get_neighbors(current_node).items():
                temp_g = g[current_node] + cost

                if neighbor not in g or temp_g < g[neighbor]:
                    g[neighbor] = temp_g
                    f = temp_g + self.heuristic.get(neighbor, float('inf'))
                    heapq.heappush(open_list, (f, neighbor))
                    parents[neighbor] = current_node

        return

    def reconstruct_path(self, parents, node, total_cost):

        path = []
        while node:
            path.append(node)
            node = parents[node]
        path.reverse()
        return f"SENTENCE: {' '.join(path)}\nCOST: {total_cost}"

# Define the heuristic function
heuristic = {
    "THE": 5,
    "DOG": 4,
    "CAT": 3,
    "BARK AT": 2,
    "NIGHT": 1
}

# Define the graph adjacency list
adjacency_list = {
    "THE": {"DOG": 2, "CAT": 2},
    "DOG": {"BARK AT": 1},
    "CAT": {"BARK AT": 2},
    "BARK AT": {"NIGHT": 1}
}

graph = Graph(adjacency_list, heuristic)
result = graph.a_star_algorithm("THE", "NIGHT")
print(result)